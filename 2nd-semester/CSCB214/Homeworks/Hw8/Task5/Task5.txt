A)
Най-големият брой сравнения се правят, когато масивът е сортиран в низходящ (обратен) ред. Именно това е и "worst case" (най-лошият) случай за алгоритъма.

Алгоритъмът винаги обхожда масива по двойки със съседни елементи и извършва n-1 обиколки, като всяка е с намаляващ брой сравнения.

Формула за броя на сравнения:
1ва обиколка: -> n - 1 сравнения
2ра -> n - 2
..... така n на брой пъти до:
(n - 1)-ва обиколка: 1

Като ги сумираме става: Cmax = (n - 1) + (n - 2) + .... + 1 = n(n-1)/2

За обяснение на практика:
даден масив има 6 елемента:
Cmax = 6*5/2 => 30/2 = 15 сравнения


Схема на преброяване:
int sravneniq = 0;
for i = 0 to n - 2:
    for j = 0 to n - i - 2:
        sravneniq++
        if a[j] > a[j + 1]:
            swap


Б)
Дори когато масивът е вече сортиран във възходящ ред, класическият bubble sort няма условие за спиране и извършва отново всички сравнения.

Затова в класическия алгоритъм брой сравненията е същият – отново: n(n−1)​/2

Реално има вариант за оптимизация, ако се добави флагване за разменена двойка и се прекъсне цикъла когато няма размени, тогава биха били нужни само n - 1 сравнения за best case. Това важи при най-добрия възможен вход – когато масивът е напълно сортиран във възходящ ред.